defmodule RESTez.Client do

  @moduledoc """
  Generates and injects functions into a module to interact with a target REST schema.

  ## Example

      defmodule TargetAPI do
        use RESTez.Client, schema: MyRestSchema

        defp endpoint(:specific, attributes, url, params, opts \\ []) do
          # custom logic for a specific endpoint
        end

        defp endpoint(id, attributes, url, params, opts \\ []) do
          # general catch-all clause for default or generic behavior
        end
      end

  ## Defining Endpoints

  The public interface of your API module will be autogenerated in the form:
  ```
  <endpoint_id>(params, opts)
  ```
  where `params` expects a map whose keys include (but are not limited to) the required parameters defined in your schema for the particular
  endpoint, and `opts` is a keyword list of request-time configuration parameters (e.g. timeout values).

  ### The `endpoint` callback
  Each endpoint function generated by the client module will call a consumer-defined callback `c:endpoint/5` with arguments processed by RESTez.
  #### Parameters
  - `id`: An identifier unique to this endpoint. This value is defined in your schema definition (see: `RESTez.Schema.Notation.endpoint/3).`
  - `attributes`: All other metadata associated with this endpoint. These values are also defined in your schema (see: `RESTez.Schema.Notation.attribute/2`).
  - `url`: The target URL after parameter interpolation.
  - `params`: Parameters supplied to the current execution of your public endpoint function. These will be automatically validated against
      the required parameters defined in your schema as well as any custom validation you supply (see: `c:validate_param/1`).
  - `opts`: Request-time options supplied to the current execution of your public endpoint function.
  """

  @default_parameter_regex ~r/(\{.+?\})/
  @default_inner_regex ~r/\{(.*?)\}/

  @callback endpoint(id :: atom(), attr :: map(), url :: binary(), params :: map(), opts :: list()) :: term()
  @callback validate_param({key :: any(), value :: any()}) :: boolean()
  @optional_callbacks validate_param: 1

  @doc false
  defmacro raise_if_no_schema(opts) do
    quote do
      schema = Keyword.get(unquote(opts), :schema)
      if !schema, do: raise CompileError, description: "Missing :schema in #{__CALLER__}", file: __CALLER__.file, line: __CALLER__.line
    end
  end

  defmacro __using__(opts) do
    raise_if_no_schema(opts)

    schema = opts[:schema]
    module = Macro.expand(schema, __ENV__)
    defs = module.__schema__() |> Enum.map(fn d -> Keyword.new(d) end)

    parameter_regex = opts[:parameter_regex] || @default_parameter_regex
    inner_regex = opts[:inner_regex] || @default_inner_regex

    interpolater = Keyword.get(opts, :interpolater) || &RESTez.Schema.interpolate_url/4

    # TODO: support methods other than GET
    endpoints = Enum.map(defs, fn d ->
      {id, attrs} = Keyword.pop!(d, :id)
      path = d[:path_template]
      quote bind_quoted: [interpolater: interpolater, id: id, attrs: attrs, path: path] do
        def unquote(id)(params, opts \\ []) do
          if validate_params(params, unquote(path)) do
            url = unquote(interpolater).(unquote(path), params)
            endpoint(unquote(id), unquote(attrs), url, params, opts)
          else
            {:error, :invalid_params}
          end
        end
      end
    end)

    quote do
      @behaviour unquote(__MODULE__)

      @parameter_regex unquote(Macro.escape(parameter_regex))
      @inner_regex unquote(Macro.escape(inner_regex))

      defp validate_params(params, url_template) do
        required = Rule.Val.Schema.get_required_params(url_template, @parameter_regex, @inner_regex)
        required_validated? = Enum.all?(required, &(params[&1]))
        Enum.reduce_while(params, required_validated?, fn p, acc ->
          still_valid? = acc and validate_param(p)
          if still_valid?, do: {:cont, true}, else: {:halt, false}
        end)
      end

      defp validate_param({_k, _v}), do: true

      unquote(endpoints)
    end
  end
end
